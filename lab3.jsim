*******************************************************************************
* LAB #3
* - Buenaobra, John Aldrich
* - Cayago, Mikylla Cherrizse
* - Sy, Mishka
*******************************************************************************

.include "8clocks.jsim"
.include "nominal.jsim"
.include "stdcell.jsim"

*******************************************************************************
* Nand Definition of a Full-Adder
* By definition
* Full Adder Sum = X ⊕ Y ⊕ Z, where Z is the Carry in
* X ⊕ Y= X!Y + !XY
* X ⊕ Y = !(!(X!Y)!(!XY))                 !NOTE A + B = (!A NAND !B)
* X ⊕ Y ⊕ CIn = !(!(X!Y)!(!XY)) ⊕ CIn    !For Simplification Purposes we will simplify X ⊕ Y as S the Sum 
* S ⊕ Z = S!Z + !SZ
* S ⊕ Z = S!Z + !SZ
* S ⊕ Z = !(!(S!Z)!(!SZ))
* Here you can either use this already to configure the subckt but we still graphed it's circuit 
* and based the inputs outputs of each Nand There for double-checking
*******************************************************************************

.subckt fa  A B Cin Sum Cout
    Xnand1 A B out1 nand2
    Xnand2 A out1 out2 nand2
    Xnand3 B out1 out3 nand2
    Xnand4 out2 out3 out4 nand2
    Xnand5 out4 Cin out5 nand2
    Xnand6 out4 out5 out6 nand2
    Xnand7 out5 Cin out7 nand2
    Xnand8 out6 out7 Sum nand2
    Xnand9 out1 out5 Cout nand2
.ends

*******************************************************************************
* 8-bit Ripple-Carry Adder (RCA8)
* Constructed by chaining 8 full adders (fa).
*******************************************************************************
.subckt rca8 a[7:0] b[7:0] c_in sum[7:0] c_out

    Xfa0 a0 b0 c_in   sum0 c1 fa
    Xfa1 a1 b1 c1     sum1 c2 fa
    Xfa2 a2 b2 c2     sum2 c3 fa
    Xfa3 a3 b3 c3     sum3 c4 fa
    Xfa4 a4 b4 c4     sum4 c5 fa
    Xfa5 a5 b5 c5     sum5 c6 fa
    Xfa6 a6 b6 c6     sum6 c7 fa
    Xfa7 a7 b7 c7     sum7 c_out fa

.ends rca8


*******************************************************************************
* 32-bit Ripple-Carry Adder using RCA8 blocks
*******************************************************************************
.subckt add32 a[31:0] b[31:0] c_in0 sum[31:0] c_out[31:30]

    * Lower 8 bits (0–7)
    Xrca0 a[7:0]    b[7:0]    c_in0    sum[7:0]    c8   rca8

    * Bits 8–15
    Xrca1 a[15:8]   b[15:8]   c8       sum[15:8]   c16  rca8

    * Bits 16–23
    Xrca2 a[23:16]  b[23:16]  c16      sum[23:16]  c24  rca8

    * Top 8 bits (24–31)
    Xrca3 a[31:24]  b[31:24]  c24      sum[31:24]  c_out[31] rca8

    * Expose the carry into MSB (from bit 30 stage) as c_out[30]
    .connect c_out[30] c24

.ends


*******************************************************************************
* 32-bit Adder
* This subcircuit is constructed by chaining 32 instances of a full-adder 
* subcircuit (`fa`). Each full adder computes:
*   - sum of one bit from A and B
*   - plus a carry-in
* producing a sum bit and a carry-out.
*
* The carry-out of each stage is connected to the carry-in of the next stage,
* creating a ripple-carry chain. 
* This produces the 32-bit sum `sum[31:0]`.
* 
*  Two carry outputs are exposed:
*   - c_out31 : the final carry out of the adder. This shows if the result
*               overflowed in unsigned addition (extra bit).
*   - c_out30 : the carry into the most significant bit (bit 31). Used together
*               with c_out31 to check signed overflow:
*
*               signed overflow = c_out30 XOR c_out31
*******************************************************************************



*******************************************************************************
* Instantiate subcircuit add32
*******************************************************************************

Xsum a[31:0] b[31:0] 0 sum[31:0] c31 c30 add32



*******************************************************************************
* These are the Digital Waveforms for testing
*******************************************************************************

* Input a[31:0]
Wa a[31:0] nrz(0, 5, 200ns, 0ns, 0.001ns, 0.001ns)
+ 0x00000000 0x55555555 0x00000000 0x55555555 0xFFFFFFFF 0x0AAAAAAA 0x00000000 0x0AAAAAAA 0x00000001 0xFFFFFFFF

* Input b[31:0]
Wb b[31:0] nrz(0, 5, 200ns, 0ns, 0.001ns, 0.001ns)
+ 0x00000000 0x00000000 0x55555555 0x55555555 0xFFFFFFFF 0x00000000 0x0AAAAAAA 0x0AAAAAAA 0xFFFFFFFF 0x00000001



.tran 2000ns

* Plot the inputs and sum output
.plot sum[30] sum[31]
.plot c30
.plot c31

.plot a[31:0]
.plot b[31:0]
.plot sum[31:0]
