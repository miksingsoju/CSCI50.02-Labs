*******************************************************************************
* LAB #3
* - Buenaobra, John Aldrich
* - Cayago, Mikylla Cherrizse
* - Sy, Mishka
*******************************************************************************

.include "8clocks.jsim"
.include "nominal.jsim"
.include "stdcell.jsim"

*******************************************************************************
* Nand Definition of a Full-Adder
* By definition
* Full Adder Sum = X â Y â Z, where Z is the Carry in
* X â Y= X!Y + !XY
* X â Y = !(!(X!Y)!(!XY))                 !NOTE A + B = (!A NAND !B)
* X â Y â CIn = !(!(X!Y)!(!XY)) â CIn    !For Simplification Purposes we will simplify X â Y as S the Sum 
* S â Z = S!Z + !SZ
* S â Z = S!Z + !SZ
* S â Z = !(!(S!Z)!(!SZ))
* Here you can either use this already to configure the subckt but we still graphed it's circuit 
* and based the inputs outputs of each Nand There for double-checking
*******************************************************************************

.subckt fa  A B Cin Sum Cout

    Xnand1 A B out1 nand2
    Xnand2 A out1 out2 nand2
    Xnand3 B out1 out3 nand2
    Xnand4 out2 out3 out4 nand2
    Xnand5 out4 Cin out5 nand2
    Xnand6 out4 out5 out6 nand2
    Xnand7 out5 Cin out7 nand2
    Xnand8 out6 out7 Sum nand2
    Xnand9 out1 out5 Cout nand2

.ends

*******************************************************************************
* 4-bit Adder
* Constructed by chaining 4 full adders (fa).
*******************************************************************************
.subckt rca4 a[3:0] b[3:0] c_in sum[3:0] c_out

    Xfa0 a0 b0 c_in    sum0 c1 fa
    Xfa1 a1 b1 c1      sum1 c2 fa
    Xfa2 a2 b2 c2      sum2 c3 fa
    Xfa3 a3 b3 c3      sum3 c_out fa

.ends

*******************************************************************************
* 32-bit Ripple-Carry Adder using RCA4 blocks
*******************************************************************************
.subckt RCA4add32 a[31:0] b[31:0] c_in0 sum[31:0] c_out[31:30]

    * Lower 4 bits (0-3)
    Xrca0 a[3:0]   b[3:0]   c_in0    sum[3:0]   c4   rca4

    * Bits 4-7
    Xrca1 a[7:4]   b[7:4]   c4       sum[7:4]   c8   rca4

    * Bits 8-11
    Xrca2 a[11:8]  b[11:8]  c8       sum[11:8]  c12  rca4

    * Bits 12-15
    Xrca3 a[15:12] b[15:12] c12      sum[15:12] c16  rca4

    * Bits 16-19
    Xrca4 a[19:16] b[19:16] c16      sum[19:16] c20  rca4

    * Bits 20-23
    Xrca5 a[23:20] b[23:20] c20      sum[23:20] c24  rca4

    * Bits 24-27
    Xrca6 a[27:24] b[27:24] c24      sum[27:24] c28  rca4

    * Top 4 bits (28-31)
    Xrca7 a[31:28] b[31:28] c28      sum[31:28] c_out[31] rca4

    * Note: c_out[30] = carry into MSB (from bit 30 stage)
    *       c_out[31] = final carry out
    *       Here, c_out[30] = c28 (carry from bit 28-30 into bit 31)
    *       So expose both:
    .connect c_out[30] c28

.ends

*******************************************************************************
* 32-bit Adder
* This subcircuit is constructed by chaining 32 instances of a full-adder 
* subcircuit (`fa`). Each full adder computes:
*   - sum of one bit from A and B
*   - plus a carry-in
* producing a sum bit and a carry-out.
*
* The carry-out of each stage is connected to the carry-in of the next stage,
* creating a ripple-carry chain. 
* This produces the 32-bit sum `sum[31:0]`.
* 
*  Two carry outputs are exposed:
*   - c_out31 : the final carry out of the adder. This shows if the result
*               overflowed in unsigned addition (extra bit).
*   - c_out30 : the carry into the most significant bit (bit 31). Used together
*               with c_out31 to check signed overflow:
*
*               signed overflow = c_out30 XOR c_out31
*******************************************************************************

.subckt add32 a[31:0] b[31:0] c_in0 sum[31:0] c_out[31:30]

    * fa is instantiated here, starting with an initial carry in 
    XFa0  a0  b0  c_in0  sum0  c_out0  fa

    * the carry out of the previous stage is now the carry in for this stage,
    * creating a ripple effect
    XFa1  a1  b1  c_out0 sum1  c_out1  fa

    * this pattern of using previous carry out 
    * as the carry in continues in the next stages

    XFa2  a2  b2  c_out1 sum2  c_out2  fa
    XFa3  a3  b3  c_out2 sum3  c_out3  fa
    XFa4  a4  b4  c_out3 sum4  c_out4  fa
    XFa5  a5  b5  c_out4 sum5  c_out5  fa
    XFa6  a6  b6  c_out5 sum6  c_out6  fa
    XFa7  a7  b7  c_out6 sum7  c_out7  fa
    XFa8  a8  b8  c_out7 sum8  c_out8  fa
    XFa9  a9  b9  c_out8 sum9  c_out9  fa
    XFa10 a10 b10 c_out9  sum10 c_out10 fa
    XFa11 a11 b11 c_out10 sum11 c_out11 fa
    XFa12 a12 b12 c_out11 sum12 c_out12 fa
    XFa13 a13 b13 c_out12 sum13 c_out13 fa
    XFa14 a14 b14 c_out13 sum14 c_out14 fa
    XFa15 a15 b15 c_out14 sum15 c_out15 fa
    XFa16 a16 b16 c_out15 sum16 c_out16 fa
    XFa17 a17 b17 c_out16 sum17 c_out17 fa
    XFa18 a18 b18 c_out17 sum18 c_out18 fa
    XFa19 a19 b19 c_out18 sum19 c_out19 fa
    XFa20 a20 b20 c_out19 sum20 c_out20 fa
    XFa21 a21 b21 c_out20 sum21 c_out21 fa
    XFa22 a22 b22 c_out21 sum22 c_out22 fa
    XFa23 a23 b23 c_out22 sum23 c_out23 fa
    XFa24 a24 b24 c_out23 sum24 c_out24 fa
    XFa25 a25 b25 c_out24 sum25 c_out25 fa
    XFa26 a26 b26 c_out25 sum26 c_out26 fa
    XFa27 a27 b27 c_out26 sum27 c_out27 fa
    XFa28 a28 b28 c_out27 sum28 c_out28 fa
    XFa29 a29 b29 c_out28 sum29 c_out29 fa
    XFa30 a30 b30 c_out29 sum30 c_out[30] fa

    * this subcircuit outputs the last sum, sum31 
    XFa31 a31 b31 c_out30 sum31 c_out[31] fa

.ends


*******************************************************************************
* Another 32-bit Ripple-Carry Adder 
* This subcircuit is constructed by chaining 32 instances of a full-adder 
* subcircuit (`fa`). Each full adder computes:
*   - sum of one bit from A and B
*   - plus a carry-in
* producing a sum bit and a carry-out.
*
* The carry-out of each stage is connected to the carry-in of the next stage,
* creating a ripple-carry chain. 
* This produces the 32-bit sum `sum[31:0]`.
*
*The trick is that these full adders are created through an iteration 
*where it takes in a b c sum c+1 then a1 b1 c+1 sum c+2
*the carry outs are automatically connected to the next iteration's carry in
*******************************************************************************

.subckt add32i a[31:0] b[31:0] c_in0 sum[31:0] c_out[31:30]

    *use the .connect from quickref to connect the inputs and outputs
    .connect c[0] c_in0

    *iterate the full adders
    XFa[0:30] a[0:30] b[0:30] c[0:30] sum[0:30] c[1:31] fa
    XFa31 a31 b31 c31 sum31 c32 fa

    .connect c_out[30] c[31]
    .connect c_out[31] c32   

.ends
*******************************************************************************
* Instantiate subcircuit add32
*******************************************************************************

Xsum a[31:0] b[31:0] 0 sum[31:0] c31 c30 add32i

*******************************************************************************
* These are the Digital Waveforms for testing
*******************************************************************************

* Input a[31:0]
Wa a[31:0] nrz(0, 5, 200ns, 0ns, 0.001ns, 0.001ns)
+ 0x00000000 0x55555555 0x00000000 0x55555555 0xFFFFFFFF 0x0AAAAAAA 0x00000000 0x0AAAAAAA 0x00000001 0xFFFFFFFF

* Input b[31:0]
Wb b[31:0] nrz(0, 5, 200ns, 0ns, 0.001ns, 0.001ns)
+ 0x00000000 0x00000000 0x55555555 0x55555555 0xFFFFFFFF 0x00000000 0x0AAAAAAA 0x0AAAAAAA 0xFFFFFFFF 0x00000001   

.tran 2000ns

* Plot the inputs and sum output
.plot c30
.plot c31

.plot a[31:0]
.plot b[31:0]
.plot sum[31:0]


*******************************************************************************
* Results 
*
* a) 0x00000000 + 0x00000000
* C30 - 237ps - 0
* C31 - 214ps - 0 
* Sum - 314ps
* Output = 0x00000000

* b) 0x55555555 + 0x00000000
* C30 - 373ps - 0
* C31 - 214ps - 0 
* Sum - 451ps
* Output = 0x55555555

* c) 0x00000000 + 0x55555555
* C30 - 372ps - 0
* C31 - 214ps - 0 
* Sum - 452
* Output = 0x55555555

* d) 0x55555555 + 0x55555555
* C30 - 130ps - 1
* C31 - 214ps - 0 
* Sum - 314
* Output matches expected result

* e) 0xFFFFFFFF + 0xFFFFFFFF
* C30 - 130ps - 1
* C31 - 95ps - 1
* Sum - 320ps
* Output = 0xFFFFFFFE

* f) 0xAAAAAAAA + 0x00000000
* C30 - 237ps - 0
* C31 - 351ps - 0
* Sum - 452ps
* Output = 0xAAAAAAAA

* g) 0x00000000 + 0xAAAAAAAA
* C30 - 237ps - 0
* C31 - 351ps - 0
* Sum - 452ps
* Output = 0xAAAAAAAA

* h) 0xAAAAAAAA + 0xAAAAAAAA
* C30 - 237ps - 0
* C31 - 94ps - 1
* Sum - 314ps 
* Output = 0x55555554

*******************************************************************************
* SPECIAL TEST CASES:
* i) 0x00000001 + 0xFFFFFFFF
* C30 - 4.08ns - 1
* C31 - 4.17ns - 1
* Sum - 4.22ns 
* Output = 0x00000000

* j) 0xFFFFFFFF + 0x00000001
* C30 - 4.08ns - 1
* C31 - 4.17ns - 1
* Sum - 4.224 ns 
* Output = 0x00000000

*******************************************************************************

*******************************************************************************
* Analysis
* 
* Most additions (aâh) settle quickly: 300â450 ps total delay.*
* These cases either donât generate carries or the carry propagates only a short distance before dying out.
*
* The last two items (i-j) require the carry to ripple through all 32 stages.
*
* Delay is ~4.1â4.2 ns, which is approximately 10Ã slower than the other cases.
********************************************************************************
