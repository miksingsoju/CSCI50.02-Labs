*******************************************************************************
* LAB #5
* - Buenaobra, John Aldrich
* - Cayago, Mikylla Cherrizse
* - Sy, Mishka
*******************************************************************************

.include "8clocks.jsim"
.include "nominal.jsim"
.include "stdcell.jsim"

* Full adder
.subckt fa a b c_in sum c_out
  Xnand1 a b out1 nand2
  Xnand2 a out1 out2 nand2
  Xnand3 b out1 out3 nand2
  Xnand4 out2 out3 out4 nand2

  * this uses the carry_in as one of the inputs
  Xnand5 out4 c_in out5 nand2

  Xnand6 out4 out5 out6 nand2
  Xnand7 out5 c_in out7 nand2

  * This outputs the sum
  Xnand8 out6 out7 sum nand2

  * This outputs the carry out
  Xnand9 out1 out5 c_out nand2
.ends

* 32-bit adder
.subckt add32 a[31:0] b[31:0] cin0 sum[31:0] cout[31:30]
  Xadder a[31:0] b[31:0] cout[30:0] cin0 sum[31:0] cout[31:0] fa
.ends

*******************************************************************************
* Lab 5: Subtractor and Comparator
*******************************************************************************
.subckt as32 a[31:0] b[31:0] op0 fas[31:0] n v z
  *inverts b
  Xinv b[31:0] b_inv[31:0] inverter

  *chooses between b or inv b depending on op code
  Xmux op0#32 b[31:0] b_inv[31:0] b_sel[31:0] mux2

  *adder/subtractor
  Xadd a[31:0] b_sel[31:0] op0 fas[31:0] cout[31:30] add32

  *negative flag
  .connect fas[31] n 

  *zero flag
  Xnor0 fas[0:3] n0 nor4
  Xnor1 fas[4:7] n1 nor4
  Xnor2 fas[8:11] n2 nor4
  Xnor3 fas[12:15] n3 nor4
  Xnor4 fas[16:19] n4 nor4
  Xnor5 fas[20:23] n5 nor4
  Xnor6 fas[24:27] n6 nor4
  Xnor7 fas[28:31] n7 nor4

  Xnand1 n[0:3] m1 nand4
  Xnand2 n[4:7] m2 nand4

  Xnor9 m1 m2 z nor2

  *overflow flag
  Xof cout[31] cout[30] v xor2
.ends

.subckt cmp32 n v z op[2:1] fcmp[31:0]
  * fcmp[0] = result bit, others grounded
  .connect 0 fcmp[1:31]

  * A = B: z
  * A < B: n XOR v (for signed comparison)
  Xxor n v a_lessthan_b xor2

  * Select between equality check (z) and less-than check (a_lessthan_b)
  Xmux1 op1 z a_lessthan_b temp1 mux2

  * Select final result based on op2
  Xmux2 op2 a_lessthan_b temp1 fcmp0 mux2
.ends

*******************************************************************************
* Instantiate as32 + cmp32 chain
*******************************************************************************

.subckt as_cmp32 a[31:0] b[31:0] op[2:0] fcmp[31:0] fas[31:0] n v z
  Xas32 a[31:0] b[31:0] op[0] fas[31:0] n v z as32
  Xcmp32 n v z op[2:1] fcmp[31:0] cmp32
.ends

Xascmp a[31:0] b[31:0] op[2:0] fcmp[31:0] fas[31:0] n v z as_cmp32

Wa a[31:0] nrz(0, 5, 20ns, 0ns, 0.001ns, 0.001ns)
+ 0 0x55555555 0 0x55555555 -1 0 0 0xAAAAAAAA 0 0xAAAAAAAA 1 -1 0x80000000 -1
Wb b[31:0] nrz(0, 5, 20ns, 0ns, 0.001ns, 0.001ns)
+ 0 0 0x55555555 0x55555555 -1 0 -1 0 0xAAAAAAAA 0xAAAAAAAA -1 1 0x80000000 -1
Wop op[2:0] nrz(0, 5, 20ns, 0ns, 0.001ns, 0.001ns)
+ 000 000 000 000 000 001 001 000 000 000 000 000 000 001

*******************************************************************************
* Plot 
*******************************************************************************
.tran 300ns
.plot a[31:0]
.plot op0
.plot op[2:1]
.plot b[31:0]
.plot fas[31:0]
.plot fcmp[31:0]
.plot n
.plot v
.plot z

*******************************************************************************
* Critical Path Analysis
*******************************************************************************

*******************************************************************************
* Start Node - a[0] or b[0] (LSB inputs)
* End Node - fcmp [0] (comparison result output)

* Path Components
* 1. Input Inverter or MUX (subtraction)
*   b[0] --> inverter --> b_inv[0] --> mux2 --> b_sel[0]
*
* 2. 32 bit Adder Carry Chain
* a[0]/b_sel[0] --> FA 0 --> cout[0] ... 
* --> FA30 --> cout[30] --> FA31 --> fas[31] and cout[31]
*
* 3. Flag Generation
*   fas[31] --> n
*   fas[0:31] --> z (8×NOR4 → 2×NAND4 → NOR2 → z)
*   cout[31]/cout[30] --> XOR2 --> v
*
* 4. Comparator Logic
*   n + v --> XOR2 --> a_lessthan_b
*   z --> MUX selection
*   Final MUX --> fcmp[0]

* Critical Path Gates
*   1 Inverter
*   1 2-input MUX
*   32 FUll Adders
*   1 XOR2 (Overflow, Less Than)
*   2 2-input MUX (Comparator)

* Longest Logic Level
* b[0] --> inverter --> mux2 --> FA0 --> FA1 --> ... --> FA31 
* --> fas[31] --> n --> XOR2 --> a_lessthan_b --> MUX2 --> fcmp[0]

* Total Gate Delays
* 
*******************************************************************************
















