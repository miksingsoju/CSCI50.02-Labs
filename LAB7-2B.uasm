|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
| In place Sorting Array
|
| Important notes:
| 1. For Lab 7, you are expected to mark the data portions of your program
|    using labels, as demonstrated below using the labels INPUT: and OUTPUT:.
| 2. While this sample program should work fine with most user inputs, there
|    is an edge case that will cause this program to fail catastrophically.
|    (Can you figure it out?)
|
| Happy hacking! - eric, ros, gab

|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||



|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
| In Place Array Sorting:
|
| Input: 
|       Array length N at ARRAY memory location  
|       Followed by N numbers to sort 
|
| Output: Sorted numbers stored at ARRAY

|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

.include beta.uasm

        LD(r31, ARRAY, r0)         | r0 = N
        BEQ(r0, DONE)              | if N == 0 → halt

        ADDC(r31, 0, r1)           | r1 = i = 0
        ADDC(r31, ARRAY, r2)       | r2 = base address (ARRAY)
        ADDC(r2, 4, r2)            | move r2 to first element (skip N)

OUTER_LOOP:
        SUBC(r0, 1, r3)            | r3 = N - 1
        CMPLT(r1, r3, r4)          | r4 = (i < N-1)
        BEQ(r4, DONE)              | if not, done

        ADDC(r31, 0, r5)           | j = 0
        ADDC(r31, 0, r6)           | swapped = 0

INNER_LOOP:
        SUB(r0, r1, r7)            | r7 = N - i
        SUBC(r7, 1, r7)            | r7 = N - i - 1
        CMPLT(r5, r7, r8)          | (j < N - i - 1)?
        BEQ(r8, CHECK_SWAPPED)     | if false, end inner loop

        MULC(r5, 4, r9)            | r9 = j * 4
        ADD(r2, r9, r9)            | r9 = &arr[j]
        ADDC(r9, 4, r10)           | r10 = &arr[j+1]

        LD(r9, 0, r13)             | r13 = arr[j]
        LD(r10, 0, r14)            | r14 = arr[j+1]

        CMPLT(r14, r13, r11)       | (arr[j+1] < arr[j]) ?
        BEQ(r11, NOSWAP)           | if false → no swap

        ST(r9, 0, r14)             | arr[j]   = arr[j+1]
        ST(r10, 0, r13)            | arr[j+1] = arr[j]
        ADDC(r31, 1, r6)           | swapped = 1

NOSWAP:
        ADDC(r5, 1, r5)            | j++
        BR(INNER_LOOP)

CHECK_SWAPPED:
        BEQ(r6, DONE)              | if swapped == 0 → already sorted
        ADDC(r1, 1, r1)            | i++
        BR(OUTER_LOOP)

DONE:
        HALT()

|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

| The "." statement changes the current memory location of any succeeding
| UASM macros, so that it is easy to locate in the BSim window.
| - If you omit this statement, the INPUT memory block would begin directly
|   after your program block.
| - You may need to adjust this memory location to make more memory space for
|   your data.
. = 0x19C

| INPUT marks the beginning of the memory block containing the hardcoded
| user "input".
ARRAY:  LONG(3)             | <-- length of the array
        LONG(7)             | <-- first element of the array
        LONG(5)             
        LONG(8)
       

