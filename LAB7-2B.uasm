|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
| In place Sorting Array
|
| Important notes:
| 1. For Lab 7, you are expected to mark the data portions of your program
|    using labels, as demonstrated below using the labels INPUT: and OUTPUT:.
| 2. While this sample program should work fine with most user inputs, there
|    is an edge case that will cause this program to fail catastrophically.
|    (Can you figure it out?)
|
| Happy hacking! - eric, ros, gab

|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||



|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
| In Place Array Sorting:
|
| Input: 
|       Array length N at ARRAY memory location  
|       Followed by N numbers to sort 
|
| Output: Sorted numbers stored at ARRAY

|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

.include beta.uasm          | include the standard predefined macros

|int N = 7; 
|int[] arr = {64, 34, 25, 12, 22, 11, 90}; 
        LD(r31, ARRAY, r0)         | r0 = N (array length)

|int i = 0; 
        ADDC(r31, 0, r1)           | r1 = i = 0 (outer loop)
        ADDC(r31, ARRAY, r2)       | r2 = base address (points to N)
        ADDC(r2, 4, r2)            | move r2 to first element (skip N)

|while (i < N - 1) { 
OUTER_LOOP:
        SUBC(r0, 1, r3)            | r3 = r0 - 1 -> N - 1
        COMPLE(r1, r3, r4)         | r4 = r1 < r3 
        BEQ(r4, DONE)              | DONE if r4 is 0
        
| int j = 0;
        ADDC(r31, 0, r5)            | r5 = j = 0

| int swapped = 0; 
        ADDC(r31, 0, r6)            | r6 = swapped = 0

| while (j < N - i - 1) { 
INNER_LOOP:
        SUB(r0, r1, r7)             | r7 = r0 - r1 -> N - i
        SUBC(r7, 1, r7)             | r7 = r7 - 1 
        COMPLT(r5, r7, r8)          | r8 TRUE if r5 < r7 -> j < N - i - 1
        BEQ(r8, OUTER_LOOP)

| if (arr[j] > arr[j + 1]) { 
        MULC(r5, 4, r9)             | r9 = j * 4 (word offset)
        ADD(r2, r9, r9)             | r9 = r2 + r9 -> &arr[j]

        LD(r9, 0, r10)             | r10 = arr[j]
        LD(r9, 4, r11)             | r11 = arr[j+1]

        COMPLT(r10, r11, r12)      | r12 = r10 < r11 
        BNE(r12, NOSWAP)

| // swap arr[j] and arr[j+1] 
| int temp = arr[j]; 
        

| arr[j] = arr[j + 1]; 

| arr[j + 1] = temp; 

| swapped = 1; 
| } 

| j = j + 1; 
| } 

| if (swapped == 0) { 

| break; // no swaps â†’ already sorted 

| } 

| i = i + 1; 

|}

NOSWAP:
        

        
CHECK_SWAPPED:


DONE: 
        HALT()

|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

| The "." statement changes the current memory location of any succeeding
| UASM macros, so that it is easy to locate in the BSim window.
| - If you omit this statement, the INPUT memory block would begin directly
|   after your program block.
| - You may need to adjust this memory location to make more memory space for
|   your data.
. = 0x19C

| INPUT marks the beginning of the memory block containing the hardcoded
| user "input".
ARRAY:  LONG(7)
        LONG(5)             | <-- length of the array
        LONG(7)             | <-- first element of the array
        LONG(8)
        LONG(6)
        LONG(4)
        LONG(9) 
        LONG(3)             | <-- last element of the array

