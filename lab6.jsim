*******************************************************************************
* LAB #5
* - Buenaobra, John Aldrich
* - Cayago, Mikylla Cherrizse
* - Sy, Mishka
*******************************************************************************

.include "8clocks.jsim"
.include "nominal.jsim"
.include "stdcell.jsim"

*******************************************************************************

* Full adder
.subckt fa a b c_in sum c_out
  Xxor1 a b xor_ab xor2
  Xxor2 xor_ab c_in sum xor2

  Xnand1 a b nand_ab nand2
  Xnand2 xor_ab c_in nab_xor_cin nand2
  Xnand3 nab_xor_cin nand_ab c_out nand2
.ends


*******************************************************************************

* 32-bit adder
.subckt add32 a[31:0] b[31:0] cin0 sum[31:0] cout[31:30]
  Xadder a[31:0] b[31:0] cout[30:0] cin0 sum[31:0] cout[31:0] fa
.ends



* Adder/Subtractor
.subckt as32 a[31:0] b[31:0] op0 fas[31:0] n v z
  *inverts b
  Xinv b[31:0] b_inv[31:0] inverter

  *chooses between b or inv b depending on op code
  Xmux op0#32 b[31:0] b_inv[31:0] b_sel[31:0] mux2

  *adder/subtractor
  Xadd a[31:0] b_sel[31:0] op0 fas[31:0] cout[31:30] add32

  *negative flag
  .connect fas[31] n 

  *zero flag
  * this block checks if each 4-bit group are all zeroes
  * by using nor gates
  * Each nor4 outputs 1 ONLY IF that 4-bit group is all zero

  Xnor0 fas[0:3] n0 nor4
  Xnor1 fas[4:7] n1 nor4
  Xnor2 fas[8:11] n2 nor4
  Xnor3 fas[12:15] n3 nor4
  Xnor4 fas[16:19] n4 nor4
  Xnor5 fas[20:23] n5 nor4
  Xnor6 fas[24:27] n6 nor4
  Xnor7 fas[28:31] n7 nor4

  * Nand the first and second half
  * If all groups are 1 (which means the nor4s are all zero)
  * the 2 nand gates will output 0
  
  Xnand1 n[0:3] m1 nand4
  Xnand2 n[4:7] m2 nand4

  * If both halves are 0, z will be 1, which means all are zero = true
  * and vice versa
  Xnor9 m1 m2 z nor2

  *overflow flag
  Xof cout[31] cout[30] v xor2
.ends

*******************************************************************************

* Comparator
.subckt cmp32 n v z op[2:1] fcmp[31:0]
  * fcmp[0] = result bit, others grounded
  .connect 0 fcmp[1:31]

  * A = B: z
  * A < B: n XOR v (for signed comparison)
  Xxor n v a_less_than_b xor2
  
  *if op2 or op1 is 1, and their conditions are true raise 1
  Xand1 op[2] a_less_than_b is_less_than and2
  Xand2 op[1] z is_equal and2

  *final result, less than or equal
  Xor1 is_less_than is_equal fcmp0 or2
.ends

*******************************************************************************

* ASCMP Combined
.subckt as_cmp32 a[31:0] b[31:0] op[2:0] fcmp[31:0] fas[31:0] n v z
  Xas32 a[31:0] b[31:0] op[0] fas[31:0] n v z as32
  Xcmp32 n v z op[2:1] fcmp[31:0] cmp32
.ends

*******************************************************************************

*******************************************************************************
* Bitwise Boolean

* Each bit of (a[i], b[i]) feeds into a mux4 structure controlled by op[3:0]
* The selected Boolean function is applied BITWISE across all 32 bits.

.subckt bool32 a[31:0] b[31:0] op[3:0] fbool[31:0]
  Xbool a[0:31] b[0:31] op[3:0]#32 fbool[0:31] mux4
.ends

*******************************************************************************
* 32-bit Shifter
.subckt shift32 a[31:0] b[4:0] op[1:0] fshift[31:0]

* op[1:0] encoding:
*   00 = logical left shift (LLS)
*   01 = logical right shift (LRS)
*   11 = arithmetic right shift (ARS)
*   10 = DONT CARE

* Control signals
  * shift_left = NOR(op1, op0)
  Xshift_left op[1] op[0] shift_left nor2
  Xnand_ars op[1] op[0] arith_shift_n nand2
   * invert to get AND
  Xinv_ars arith_shift_n arith_shift inverter

* Determine fill bit for right shifts (0 for logical, sign bit for arithmetic)
*   if arith_shift = 1 -> fill_bit = a[31]
*   if arith_shift = 0 -> fill_bit = 0
  Xmux_fill arith_shift 0 a[31] fill_bit mux2

*feeds reversed input when left shift is needed
  Xmux_pre shift_left#32 a[31:0] a[0:31] a_eff[31:0] mux2

*Only have right shift
*With the idea that reversing the input and output would lead to the left shift instead
  XmuxR1 b[0]#31 a_eff[31:1] fill_bit#31 s1R[30:0] mux2
  .connect s1R[31] fill_bit

  XmuxR2 b[1]#30 s1R[31:2] fill_bit#30 s2R[29:0] mux2
  .connect s2R[31:30] fill_bit#2

  XmuxR3 b[2]#28 s2R[31:4] fill_bit#28 s3R[27:0] mux2
  .connect s3R[31:28] fill_bit#4

  XmuxR4 b[3]#24 s3R[31:8] fill_bit#24 s4R[23:0] mux2
  .connect s4R[31:24] fill_bit#8

  XmuxR5 b[4]#16 s4R[31:16] fill_bit#16 s5R[15:0] mux2
  .connect s5R[31:16] fill_bit#16
  
*feeds reversed output when left shift is needed
  Xmux_post shift_left#32 s5R[31:0] s5R[0:31] fshift[31:0] mux2
.ends
*******************************************************************************

* ALU
.subckt alu32 a[31:0] b[31:0] alufn[5:0] f[31:0]
  Xas_cmp32 a[31:0] b[31:0] alufn[2:0] fcmp[31:0] fas[31:0] n v z as_cmp32
  Xbool32 a[31:0] b[31:0] alufn[3:0] fbool[31:0] bool32
  Xshift32 a[31:0] b[4:0] alufn[1:0] fshift[31:0] shift32

  Xout alufn[4]#32 alufn[5]#32 fas[31:0] fbool[31:0] fshift[31:0] fcmp[31:0] f[31:0] mux4
.ends

*******************************************************************************
* Instantiate alu32 circuit
*******************************************************************************

Xalu a[31:0] b[31:0] alufn[5:0] f[31:0] alu32

*******************************************************************************
* Test Cases for alu32
*******************************************************************************

Wa a[31:0] nrz(0v,5.0v,20ns,0ns,.1ns,.1ns)
+ -1 0x55555555 0xAAAAAAAA 1 -2 -1 -1 0x55555555 0 -1 0x55555555 0
+ -1 0x55555555 0 -1 0x55555555 0 -1 0x55555555 0 1 -1 -1 0x55555555 0xAAAAAAAA -1
+ 0x55555555 0xAAAAAAAA -1 -1 15 0 -1 15 0 -1 15 0

Wb b[31:0] nrz(0v,5.0v,20ns,0ns,.1ns,.1ns)
+ 1 0x55555555 0xAAAAAAAA 1 0 -1 -1 0xAAAAAAAA 0 -1 0xAAAAAAAA 0
+ -1 0xAAAAAAAA 0 -1 0xAAAAAAAA 0 -1 0xAAAAAAAA 0 31 15 0 24 24 31
+ 24 24 31 1 15 -256 1 15 -256 1 15 -256

Wf alufn[5:0] nrz(0v,5.0v,60ns,0ns,.1ns,.1ns)
+ 0 1 24 30 22 26 21 32 33 35 51 53 55 

*******************************************************************************
* Show via plot 
*******************************************************************************
.tran 600ns
.plot a[31:0]
.plot b[31:0]
.plot alufn[5:0]
.plot f[31:0]

*******************************************************************************
* Determining Circuit Size
*******************************************************************************
* Circuit Size = 629 gates (13661.0 microns)

* Changed our original all NAND Full Adder to have 2 XOR + 3 NANDs instead

* Adder/Subtractor (as32) reuses the same optimized adder and adds a few MUX, NOR, and NAND gates for control, z, n, and v flags

* Comparator (cmp32) uses a few XOR, AND, and OR gates to check equality and less-than conditions

* Bitwise Boolean (bool32) mainly uses MUX4 gates to choose between AND, OR, XOR, and NOT operations

* Shifter originally accounted for both right and left shift, we figured out we could simply recycle left shift by reversing the input and output of the shifter
* ALU integrates all modules using MUX4 to select correct function output

*******************************************************************************


